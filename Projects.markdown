---
layout: page
title: Course Summary
permalink: /Projects/
---
These projects will introduce you to number systems, bases, sets, and Boolean algebra; as well as functions, relations, and induction. By using these methods I’ve learned how challenging a simplistic problem can actually be. Since every problem can be approached and solved in multiple ways, it's important to consider what's the most efficient way to solve a problem. By using discrete mathematics and determining the most efficient means of approaching a problem I’m able to approach any problem in the most time efficient way through this course.

The biggest challenge in this course thus far for me has been learning binomials. When looking at a single chest piece at first glance what I imagine is how the piece can actually move. When the average person moves a chest piece they don't consider all of the ways it can move to that location. An example being a rook that wants to move from its starting position no matter where it moves it follows Pascal’s triangle. All pieces essentially follow the Pascal triangle! The farther a piece moves the more possibilities it has in terms of pathing to get there.

Some major key points to take away from what I've learned is to always think about the list of outcomes that come from a single problem. No problem has to be approached in a linear fashion. If a selection is made or there can’t be any repeats it's important to consider combinations and permutations. With combinations and permutations we can form subsets moreover from subsets we can form along with possibilities and amount of outcomes. As stated before every problem can be solved in multiple ways but it's most important to solve a problem the most efficient way using binomials.  

Sequences are also fascinating in the sense that they're a set of numbers that follow the same rule whether that be each number is more or less than the next. An example being recursion being that its a repeated procedure for that's successive. What can we do with recursion? With recursion we can actually construct algorithms that build list or even draw shapes because the program will follow those set of instructions however many times it needs to. Like in the post made Jun 28, 2021 the program uses a do-while loop to recursively count how many skittles are distributed to each customer. Now one thing that also fascinates me bout its uses is how it can be used for chessboard and movement for pieces.

Typically on a chessboard there's 64 spaces and 32 pieces on the board at a time. Each piece follows a different set of rules so when programing a chess game each piece follows different recursion Sequence. Lets take a pawn for example! Pawns can move forwards 1 to 2 spaces with two rules. One they can take pieces diagonal to their own and cant pass a piece right in front of their own. Why is this important? Now this might sound hard to program however by using recursion and giving each piece its own rules to follow its actually more simple than it seems. Now since the pawn can up to two spaces on its first turn that would be the first rule thus we'd use an if statement then once the pawn has moved we'd use a do-while loop. The hardest piece to program would be the pawn because if it reaches the other side it turns into a queen. How would we determine if the pawns reached the end? To determine this we could use a Boolean variable that only changes to true if the pawn reaches the end. So the chess table is like a giant truth table. Each pawn has its own possibilities like we could say the pawn reaches the end. That statement could be true or it could be false but there's not guarantee it makes it past all the other pieces on the board.           
